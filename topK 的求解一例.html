<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="今天的主题来源于对“词频”的数量统计排序。假设有一个字符串数组，每个元素是一句英文单词，可以重复，需要求解数量排在前 k 的单词及它出现的次数。
这个问题的直接解法是，先统计每个单词的出现次数，然后对次数进行从大到小的排序，然后取出前 k 个元素，这样做效率上没有什么问题，比如数组 size = 2">


<link rel="alternate" href="/atom.xml" title="一个极其普通的程序员" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>一个极其普通的程序员</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">

<link rel="stylesheet" href="/css/style.css">

<nav class="main-nav">

	
	    <a href="/">← 主页</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
	
	<!--
	<a class="cta" href="/atom.xml" data-no-instant>订阅</a>
	-->
</nav>

<section id="wrapper">
    <article class="post">
    <header>
        
        <h2 class="headline">May 07 2020
        
        </h2>
    </header>
</article>
<section id="post-body"><p>今天的主题来源于对“词频”的数量统计排序。假设有一个字符串数组，每个元素是一句英文单词，可以重复，需要求解数量排在前 k 的单词及它出现的次数。</p>
<p>这个问题的直接解法是，先统计每个单词的出现次数，然后对次数进行从大到小的排序，然后取出前 k 个元素，这样做效率上没有什么问题，比如数组 size = 20，k = 10</p>
<p>进一步假设，如果数组长度比较大，远大于 k，比如 size = 1000000， k = 10，上面的解法效率就非常低，因为对这么大的数组排序是一件很耗时的操作。下面介绍在这种场景下的另一种高效率解法，所涉及的数据结构叫：优先队列（Priority Queue）</p>
<h4 id="优先队列的简单科普"><a href="#优先队列的简单科普" class="headerlink" title="优先队列的简单科普"></a>优先队列的简单科普</h4><ul>
<li>实现方式</li>
</ul>
<p>优先队列本质是一个二叉堆。二叉堆是用数组来实现的完全二叉树，所以实际上优先队列是一个用数组来实现的完全二叉树。并且它满足以下</p>
<ul>
<li>特点</li>
</ul>
<p>对于数组元素 arr[i]</p>
<ol>
<li>它的父节点序号是 (i-1) / 2</li>
<li>它的左子节点序号是 2 * i + 1</li>
<li>它的右子节点序号是 2 * i + 2</li>
<li>父节点的优先级高于它的子节点</li>
<li>初始化一个大小为 n 的堆（优先队列也是堆的一种），时间复杂度是 O(n)；如果当前队列的大小是 n，添加和取出元素的时间复杂度是 O(logn)</li>
</ol>
<p>关于第 4 点，这里的优先级是自定义的，可以是节点的数更大，也可以是节点的数更小，或者其他用来比较优先级的定义规则</p>
<p><strong>当我们取出元素的时候，一定取出的是优先级最高的那个（arr[0]）</strong></p>
<h4 id="优先队列的两个基本操作"><a href="#优先队列的两个基本操作" class="headerlink" title="优先队列的两个基本操作"></a>优先队列的两个基本操作</h4><ul>
<li>添加元素时向上筛选操作（sift up）</li>
</ul>
<p>当 Priority Queue 添加元素时，是在数组尾进行添加，接下来做优先级的判断，先跟自己的父节点做优先级比较，如果添加的元素优先级更高，则跟父节点交换位置，然后继续跟新的父节点做同样的比较，直到它交换到位置 0，或者它的优先级没有父节点高为止。这样新的元素就添加完毕</p>
<p>这个过程做个比喻像猴子爬树，新猴子跟它的直属领袖比官职，大于它就交换位置，直到它比不过上一级，或者它是首领，能爬到顶端</p>
<ul>
<li>取出元素时向下筛选（sift down）</li>
</ul>
<p>当 Priority Queue 取出元素时，取出的是数组的第 0 个元素，接下来将数组尾的元素拿到位置 0，然后与它的两个子节点中的优先级更大者比较，如果子节点更高，则交换它们的位置，并继续跟它在新的位置上的两个子节点较大者比较，直到它的优先级高于子节点，或者它到达底部位置</p>
<p><strong>这里思考，为什么要把最后一个元素提到第一个元素的位置开始做向下筛选，而不是从别的位置拿一个元素做呢？</strong></p>
<p>这是因为堆底元素是叶子节点，提出来不会破坏堆的中间结构，这样操作最简单</p>
<h4 id="优先队列的-Java-实现"><a href="#优先队列的-Java-实现" class="headerlink" title="优先队列的 Java 实现"></a>优先队列的 Java 实现</h4><p>上面分析了 Priority Queue 的特点后，我们看看 JDK 8 中是如何实现它的</p>
<p>找到 PriorityQueue，查看构造方法，重载了好几个，构造过程比较简单，不多说了</p>
<p><img src="https://note.youdao.com/yws/res/10209/0A18662BC74E401C84D8DA002B43AC97" alt="image"></p>
<p>这里主要探索它的元素添加与取出的算法在代码里是如何实现的。所以直接看 add 方法和 poll 方法</p>
<ul>
<li>add()</li>
</ul>
<p>不影响算法逻辑的代码都在下面忽略了，同时我添加了逻辑的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; add 的逻辑实现在 offer()，直接看 offer 方法</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; i 作为当前队列的长度</span><br><span class="line">        int i &#x3D; size;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 由于是添加元素，所以新的长度增加 1</span><br><span class="line">        size &#x3D; i + 1;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 只有一个元素，不需要做 “爬树”</span><br><span class="line">        if (i &#x3D;&#x3D; 0)</span><br><span class="line">            queue[0] &#x3D; e;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 需要爬树</span><br><span class="line">        else</span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看“爬树”的算法实现过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">        &#x2F;&#x2F; 回头看看构造函数，可以传递 Comparator 比较器进来</span><br><span class="line">        if (comparator !&#x3D; null)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果不传递比较器的话，添加的元素需要实现 Comparable 接口</span><br><span class="line">        else</span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>无论是传递 Comparator 还是元素自行实现 Comparable 接口，爬树逻辑都是一样的，所以这里只看 Comparator != null 的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void siftUpUsingComparator(int k, E x) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这时传递进来的 k，就是当前堆底的序号</span><br><span class="line">        &#x2F;&#x2F; 循环终止条件设定为 k &gt; 0，即爬到顶部为止 </span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 父节点的序号，&gt;&gt;&gt; 1 表示除以 2</span><br><span class="line">            int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 取出父节点的元素</span><br><span class="line">            Object e &#x3D; queue[parent];</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 比较父节点和添加元素的优先级，如果小于父节点，则停止比较</span><br><span class="line">            if (comparator.compare(x, (E) e) &gt;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; 优先级高于父节点，父节点元素对象放到位置 k</span><br><span class="line">            queue[k] &#x3D; e;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 序号提到父节点序号，做下一次的比较</span><br><span class="line">            k &#x3D; parent;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 比较完毕，得到的 k 就是当前添加元素的位置</span><br><span class="line">        queue[k] &#x3D; x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑实现过程比较清晰，跟上面讨论的内容一致。接下来看看取出元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 声明队列底部的序号</span><br><span class="line">        int s &#x3D; --size;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 取出队列顶部的元素</span><br><span class="line">        E result &#x3D; (E) queue[0];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 取出队列底部的元素</span><br><span class="line">        E x &#x3D; (E) queue[s];</span><br><span class="line">        queue[s] &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 队列底部提到位置 0，开始“下树”</span><br><span class="line">        if (s !&#x3D; 0)</span><br><span class="line">            siftDown(0, x);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看“下树”的过程实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">        int half &#x3D; size &gt;&gt;&gt; 1;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 终止条件设置为只循环队列长度的一半，为什么不是 k &lt; size ？</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 左子节点的序号</span><br><span class="line">            int child &#x3D; (k &lt;&lt; 1) + 1;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 左子节点的元素</span><br><span class="line">            Object c &#x3D; queue[child];</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 右子节点的序号</span><br><span class="line">            int right &#x3D; child + 1;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 先比较左和右子节点的优先级，取优先级更高的那个子节点元素</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">                c &#x3D; queue[child &#x3D; right];</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; 和子节点做比较，大于子节点优先级则终止</span><br><span class="line">            if (comparator.compare(x, (E) c) &lt;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; 小于子节点优先级，将子节点元素换到 k 的位置</span><br><span class="line">            queue[k] &#x3D; c;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 位置更新为子节点的位置</span><br><span class="line">            k &#x3D; child;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 新的 k 的位置，就是原队列底部元素</span><br><span class="line">        queue[k] &#x3D; x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注释中我写了一条：<strong>终止条件设置为只循环队列长度的一半，为什么不是 k &lt; size ？</strong></p>
<p>因为二叉堆是完全二叉树，最多只需要循环树的高度就可以了</p>
<h4 id="求解-topK"><a href="#求解-topK" class="headerlink" title="求解 topK"></a>求解 topK</h4><p>有了上面的知识做铺垫，回到一开始提到的问题，采用优先队列求解“词频”问题。</p>
<ul>
<li>首先用 HashMap 统计出每个词的数量</li>
<li>然后把词和对应的数量构造一个 Java bean 对象</li>
<li>构造一个按数字大小降序排列的比较器</li>
<li>将 HashMap 的元素全部推入优先队列，依靠队列的特性自动排好优先级</li>
<li>取出 k 个元素，就是我们要的前 k 个高频词汇</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; cache &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        String[] data &#x3D; &#123;&quot;car&quot;, &quot;car&quot;, &quot;desk&quot;, &quot;car&quot;, &quot;app&quot;, &quot;app&quot;, &quot;bbb&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 统计各词的频率</span><br><span class="line">        for (String d : data) &#123;</span><br><span class="line">            if (!cache.containsKey(d)) &#123;</span><br><span class="line">                cache.put(d, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cache.put(d, cache.get(d) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 构造比较器</span><br><span class="line">        Comparator&lt;Words&gt; comparator &#x3D; (o1, o2) -&gt; o2.count - o1.count;</span><br><span class="line">        PriorityQueue&lt;Words&gt; priorityQueue &#x3D; new PriorityQueue&lt;&gt;(comparator);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; HashMap 元素推入优先队列</span><br><span class="line">        for (Map.Entry&lt;String, Integer&gt; entry : cache.entrySet()) &#123;</span><br><span class="line">            Words words &#x3D; new Words(entry.getKey(), entry.getValue());</span><br><span class="line">            priorityQueue.add(words);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;词汇出现次数从高到低分别是:&quot;);</span><br><span class="line">        while (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            Words words &#x3D; priorityQueue.poll();</span><br><span class="line">            System.out.println(&quot;  &quot; + words.word + &quot;: &quot; + words.count);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://note.youdao.com/yws/res/10434/339F97330B504B06B8DE729D0FD98493" alt="image"></p>
<p>今天分享的是优先队列求解“前 k 个”问题，这一类问题都可以用优先队列解决，在面对数据量较大的 topK 时效率比传统解法高</p>
</section>
    


  <section id="comment">
    <button class="btn" id="loadcmts" onclick="cmts.load();">加载评论</button>
    <div id="gitment"></div>
    <script src='/js/gitment.browser.js'></script>
    <link rel="stylesheet" href=''>
    <script>
      var cmts={
        load:function cmts(){
          var gitment = new Gitment({
          
            owner: "",
            repo: "",
            oauth: {
              client_id: "",
              client_secret: "",
            },
          })
          gitment.render('gitment');
          var loadcmt = document.getElementById("loadcmts");
          var imyourfather = loadcmt.parentNode;
          imyourfather.removeChild(loadcmts)
        }
      }
    </script>
  </section>


	<footer id="footer">
	<div id="social">
		<p class="small">©  Henry Woo in CHJ Inc.
		</p>
	</div>
</footer>

</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
	<script data-no-instant>
		
		InstantClick.init('mousedown');
	</script>



