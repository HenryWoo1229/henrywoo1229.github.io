<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="分布式概念，通常在 Web 项目中出现，这是相比于过去将所有功能放到一个应用中而演进过来的
微服务所有功能在一个应用中，叫做单体应用，好处是开发方式简单直接，缺点是一个功能模块出现异常，将导致整个应用处于不可用状态
打个简单的比方，我们用手拿笔写字，手是一个单体应用。假设某天手的拇指划伤了，无法正常">


<link rel="alternate" href="/atom.xml" title="一个极其普通的程序员" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>什么是分布式系统 ？ - 一个极其普通的程序员</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">

<link rel="stylesheet" href="/css/style.css">

<nav class="main-nav">

	
	    <a href="/">← 主页</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
	
	<!--
	<a class="cta" href="/atom.xml" data-no-instant>订阅</a>
	-->
</nav>

<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>什么是分布式系统 ？</h1>
        
        <h2 class="headline">Apr 28 2020
        
        </h2>
    </header>
</article>
<section id="post-body"><p>分布式概念，通常在 Web 项目中出现，这是相比于过去将所有功能放到一个应用中而演进过来的</p>
<h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p>所有功能在一个应用中，叫做单体应用，好处是开发方式简单直接，缺点是一个功能模块出现异常，将导致整个应用处于不可用状态</p>
<p>打个简单的比方，我们用手拿笔写字，手是一个单体应用。假设某天手的拇指划伤了，无法正常握笔，那么我们就无法写字</p>
<p>倘若此时，我们另一只手也可以写字，就像有另一个应用一样，那么我们就能够继续完成写字任务</p>
<p>进一步想到，划伤的只是拇指，其他手指还是可以用的，如果此时有另一个拇指可以代替这个拇指完成握笔动作，那么写字这件事就能够继续进行了。所以这里的 “拇指”，就是一个核心模块</p>
<p>回到 Web 项目本身，我们把单体应用的不同功能进行模块化拆分，划分成独立的 “应用”，它们分别跑在自己的进程里，相互独立，分开部署，需要协同工作时就通过轻量级机制去通信，通常，是 HTTP API 方式，这就称为 “微服务” 架构</p>
<p>微服务有它的好处，但它相比单体应用更复杂，给部署和运维带来更大的挑战，例如，一个超大型微服务架构系统下部署的应用，可能长这样（密集恐惧症慎看）</p>
<p>![](/Users/mac/Library/Application Support/typora-user-images/image-20200428205818305.png)</p>
<h4 id="分布式和集群"><a href="#分布式和集群" class="headerlink" title="分布式和集群"></a>分布式和集群</h4><p>上面我们知道了什么是微服务，当我们把微服务应用部署到不同的地方，有的微服务负责用户登录，有的微服务处理用户订单，有的微服务处理用户支付，它们组合起来形成一套系统，这样的系统我们就叫做分布式系统</p>
<p>当某个时刻用户订单量大增，一台订单服务器已经无法扛住压力，此时需要再添加几台服务器去运行订单微服务，使得所有的订单微服务能够共同支撑订单业务，那么这几台服务器就叫做集群，一个集群用来共同完成一项任务</p>
<p>所以我们知道了，集群和分布式并不是一个概念，分布式是相对于业务系统来说的，微服务就是分布式的一种表现形式，而集群则是面向某个具体的业务块，它将单个微服务性能进行扩大</p>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><code>RPC</code>，也就是 Remote Procedure Call，远程过程调用。现在我们知道了什么是分布式系统，它的一个特点是微服务会分布在不同的地方，那么相互之间涉及到交互时，这个过程就是 RPC。在 Java 分布式框架里，有一个叫做 <code>Spring Cloud</code> 的架构，推荐 RPC 的方式是 <code>HTTP + JSON</code></p>
<p>什么意思呢，通过 HTTP 请求进行交互，并且使用 JSON 格式进行数据传递</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>到这里，我们知道集群化的微服务会部署到好几台服务器上，比如上面的订单服务，也知道微服务之间进行交互时需要 RPC，那就有个疑问，RPC 的时候到底是跟哪一台服务器上的微服务做交互呢？这里的概念就涉及到负载均衡</p>
<p>负载均衡的一个原则就是，避免某一台服务器过忙或者过闲，让各服务器都处于均衡的状态</p>
<h4 id="服务注册，服务发现及注册中心"><a href="#服务注册，服务发现及注册中心" class="headerlink" title="服务注册，服务发现及注册中心"></a>服务注册，服务发现及注册中心</h4><p>假设我们有三台服务器组成集群完成订单服务，但网络问题会导致某些服务间歇性下线上线，出现不稳定的情况，对负载均衡带来影响，这时我们需要避开那些已经下线的服务</p>
<p>所以在进行 RPC 调用时，哪些服务在线就变得很关键，注册中心就这样诞生了</p>
<p>当所有服务启动后，主动往注册中心进行服务注册，这样注册中心就是一个管理员，维护了在线的服务</p>
<p>当调用方发起 RPC 时，先去注册中心查询，也就是服务发现，看看此时哪些服务在线，就可以按照负载均衡算法完成调用</p>
<p>某个时刻，其中一台服务下线了，注册中心会自动把它踢出去，避免下一次服务发现时找到它，保证了 RCP 过程的可靠性</p>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><p>分布式系统之所以复杂，还包括它在配置的改动上。当我们的微服务特别多的时候，比如订单微服务就部署了十台，如果某个需求变了，要改改配置，我们难道要去每一台微服务上修改吗？</p>
<p>这简直太可怕了</p>
<p>所以配置中心就出现了，它集中管理着所有微服务的配置，当我们要改动订单服务时，在配置中心进行修改，那么所有的订单服务自动从配置中心拿到修改结果，自动就完成了配置更改</p>
<p>帮运维解决了一个大麻烦</p>
<p>以上，就是一套分布式系统会涉及到的概念</p>
</section>
    


  <section id="comment">
    <button class="btn" id="loadcmts" onclick="cmts.load();">加载评论</button>
    <div id="gitment"></div>
    <script src='/js/gitment.browser.js'></script>
    <link rel="stylesheet" href=''>
    <script>
      var cmts={
        load:function cmts(){
          var gitment = new Gitment({
          
            id: "什么是分布式系统 ？",
          
            owner: "",
            repo: "",
            oauth: {
              client_id: "",
              client_secret: "",
            },
          })
          gitment.render('gitment');
          var loadcmt = document.getElementById("loadcmts");
          var imyourfather = loadcmt.parentNode;
          imyourfather.removeChild(loadcmts)
        }
      }
    </script>
  </section>


	<footer id="footer">
	<div id="social">
		<p class="small">©  Henry Woo in CHJ Inc.
		</p>
	</div>
</footer>

</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
	<script data-no-instant>
		
		InstantClick.init('mousedown');
	</script>



