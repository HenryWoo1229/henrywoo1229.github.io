<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="在上一篇介绍分布式系统的文章中，针对一个分布式项目涉及到的概念做了基本介绍，我们了解了什么是微服务，什么是集群，什么是 RPC，什么是负载均衡，等等，还没看过的建议先看看《什么是分布式系统》，接下来我们继续讲完后续部分
服务熔断与服务降级微服务架构中所有的服务之间通过 RPC 调用，这就涉及到网络的">


<link rel="alternate" href="/atom.xml" title="一个极其普通的程序员" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>什么是分布式系统（二） - 一个极其普通的程序员</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">

<link rel="stylesheet" href="/css/style.css">

<nav class="main-nav">

	
	    <a href="/">← 主页</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
	
	<!--
	<a class="cta" href="/atom.xml" data-no-instant>订阅</a>
	-->
</nav>

<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>什么是分布式系统（二）</h1>
        
        <h2 class="headline">Apr 29 2020
        
        </h2>
    </header>
</article>
<section id="post-body"><p>在上一篇介绍分布式系统的文章中，针对一个分布式项目涉及到的概念做了基本介绍，我们了解了什么是微服务，什么是集群，什么是 RPC，什么是负载均衡，等等，还没看过的建议先看看《什么是分布式系统》，接下来我们继续讲完后续部分</p>
<h4 id="服务熔断与服务降级"><a href="#服务熔断与服务降级" class="headerlink" title="服务熔断与服务降级"></a>服务熔断与服务降级</h4><p>微服务架构中所有的服务之间通过 RPC 调用，这就涉及到网络的稳定性。但网络的稳定性有时是不可靠的，比如一个订单查询流程中，用户服务需要调用查询服务，查询服务需要调用库存服务，并依次返回结果</p>
<p>如果某个时间段库存服务网络不稳定，或者出异常导致响应变慢，那么就会导致该调用链路上的所有服务响应变慢的现象，如果此时又恰好遇到大并发，比如春运订单，那结果太 “美” 我不敢看</p>
<p>因此需要一个机制，在某个服务响应变慢到达一个阈值，假设连续 200 次响应超时，就直接断开此服务，其他调用此服务的服务之后就不再请求它，改为直接返回默认值，这个机制就叫做服务熔断</p>
<p>服务降级是针对整个系统而言的，当系统处在高峰期运行时，资源紧张，那么可以让一些非核心的业务降级，让它们不再处理任务，或者只是简单处理任务，比如直接返回一些默认数据，或者抛异常等等</p>
<h4 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h4><p>这是分布式系统中非常重要的一个组件，它是由微服务中都需要的公共功能抽象而来，我们可以将负载均衡，服务熔断，灰度发布，统一认证，限流，日志统计等功能做进去</p>
<p>比如我们客户端在调用服务 API 的时候，就需要先走网关，它就好像一扇大门，将符合要求的请求放进来给后端处理，不符合的就不能进入</p>
<h4 id="前后端分离的方式"><a href="#前后端分离的方式" class="headerlink" title="前后端分离的方式"></a>前后端分离的方式</h4><p>现在主流的 Web 项目开发都采用前端后端分离的方式</p>
<p>前端，就是指与用户直接交互的部分，比如网页，手机 APP，小程序等</p>
<p>后端，就是我们的分布式系统</p>
<p>通常前端部署到外网，后端部署到内网，所以现在前端能做得越来越绚丽，也是因为前端分离后有了自己的技术发展</p>
<p>前端页面将请求发到 <code>Nigix</code> 服务集群，由 Nigix 将请求发到 API 网关，网关提供了认证授权，请求路由，负载均衡，熔断降级，流量限流等功能</p>
<p>通过了网关，请求就真正到达后端要处理请求的服务上了</p>
<p>这里网关可以使用 <code>Spring Cloud Gateway</code> 框架</p>
<p>当请求从前端经过网关到达服务以后，服务与服务之间存在 RPC 调用，可以使用 <code>Spring Cloud Feign</code>，而有些服务要求特殊权限才能够被调用，比如社交功能验证，可以使用 OAuth 2.0，整体应用的安全以及权限控制，可以使用 Spring Security</p>
<p>服务与服务之间的交互，除了直接 RPC 外，还可以用消息中间件，比如 RabbitMQ，保障分布式事务的最终一致性</p>
<p>而对于有的服务，比如商品查询，需要进行全文检索，可以采用 Elastic Search</p>
<p>对于那些需要运行中存取图片或者视频的服务，可以采用阿里云的对象存储服务 OSS</p>
<p>服务的部分差不多如此，数据怎么办，得有地方存放啊</p>
<p>对于数据缓存，采用 Redis 集群，可以是分片集群 Shard，和哨兵集群 Sentinel</p>
<p>对于数据持久化，采用 MySQL 集群，可以是读写分离，或者分库分表</p>
<p>写到这里，我想不熟悉后端的人已经晕了，没关系，晕就是蜕变过程中的一环，分布式架构非常复杂，作为测试开发来说，了解它是必修课，</p>
</section>
    


  <section id="comment">
    <button class="btn" id="loadcmts" onclick="cmts.load();">加载评论</button>
    <div id="gitment"></div>
    <script src='/js/gitment.browser.js'></script>
    <link rel="stylesheet" href=''>
    <script>
      var cmts={
        load:function cmts(){
          var gitment = new Gitment({
          
            id: "什么是分布式系统（二）",
          
            owner: "",
            repo: "",
            oauth: {
              client_id: "",
              client_secret: "",
            },
          })
          gitment.render('gitment');
          var loadcmt = document.getElementById("loadcmts");
          var imyourfather = loadcmt.parentNode;
          imyourfather.removeChild(loadcmts)
        }
      }
    </script>
  </section>


	<footer id="footer">
	<div id="social">
		<p class="small">©  Henry Woo in CHJ Inc.
		</p>
	</div>
</footer>

</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
	<script data-no-instant>
		
		InstantClick.init('mousedown');
	</script>



